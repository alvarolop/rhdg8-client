= Red Hat Data Grid 8 Java client
Álvaro López Medina <alopezme@redhat.com>
v1.0, 2020-12
// Metadata
:description: This repository contains a simple Java example that interacts with Data Grid
:keywords: infinispan, datagrid, openshift, red hat, java
// Create TOC wherever needed
:toc: macro
:sectanchors:
:sectnumlevels: 2
:sectnums: 
:source-highlighter: pygments
:imagesdir: images
// Start: Enable admonition icons
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
// Icons for GitHub
:yes: :heavy_check_mark:
:no: :x:
endif::[]
ifndef::env-github[]
:icons: font
// Icons not for GitHub
:yes: icon:check[]
:no: icon:times[]
endif::[]
// End: Enable admonition icons

This repository demonstrates how to connect to and use the latest release of Red Hat Data Grid 8.

// Create the Table of contents here
toc::[]



== Introduction

RHDG provides libraries in several programming languages to consume entries stored in the grid. However, in this section, we will focus on the highly-optimized HotRod Java client. Here the https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.4/html/hot_rod_java_client_guide/index[documentation].








== Run it! Part 1: Deploy the server

This Spring Boot application needs a running Red Hat Data Grid server to connect to either on OCP or locally. If you need help with this task, you can check the code that I have in this sibling repository: https://github.com/alvarolop/rhdg8-server[alvarolop/rhdg8-server].

If you don't want a complex setup, you can use the easiest way to deploy the server:

[source, bash]
----
podman run -it -p 11222:11222 -e USER="admin" -e PASS="password" --net=host quay.io/infinispan/server:14.0
----


== Run it! Part 2: Configure the schema

This application uses several caches to stores and indexes a Book object serialized using Protostream. Therefore, both the server and the client need to know the details of the serialization. While the client application knows it thanks to several annotations, we need to send the `book.proto` definition to the server prior to running the client application.

There are several mechanisms, but probably the REST API is the easiest one:

[source, bash]
----
# Server deployed locally
curl -X POST -k -v -u admin:password --digest localhost:11222/rest/v2/schemas/book.proto -d @protos/book.proto

# Server on OCP
curl -X POST -k -v $RHDG_SECURITY $RHDG_SERVER_ROUTE/rest/v2/schemas/book.proto -d @protos/book.proto
----



== Run it! Part 3: Run your application


=== Run it locally

Just use the following command to launch the application locally and test it:


[source, bash]
----
mvn clean spring-boot:run
----



=== Run it on Openshift

Deploying your client application on OCP requires to create several Openshift objects. Therefore, we are going to define some common variables that will be used from now onwards:

[source, bash]
----
export APP_NAME=rhdg8-client
export APP_NAMESPACE=rhdg8
export RHDG_CLUSTER=rhdg
export GIT_REPO=https://github.com/alvarolop/rhdg8-client.git
----

==== App configuration

First, create a ConfigMap that will store your application configuration:
[source, bash]
----
oc create configmap $APP_NAME-config \
--from-file=application.properties=src/main/resources/application-k8s.properties \
--from-file=logback-spring.xml=src/main/resources/logback-spring-k8s.xml -n $APP_NAMESPACE
----


==== App deployment

Second, use an Openshift template to create the resources. There are two templates inside the `templates` folder:

[cols="5*",options="header",width=100%]
|===
|Template
|Authentication
|Authorization
|SSL Encryption
|Notes

| link:templates/rhdg-client-basic.yaml[Basic]
|{yes} Not by default
|{yes} Not by default
|{no}  Not possible
|Does not allow SSL encryption
 
| link:templates/rhdg-client-ssl.yaml[SSL]
|{yes} Not by default
|{yes} Not by default
|{yes}  By default
|Mounts `.pem` file in the container

|===


This is the command to apply the template on your cluster:
[source, bash]
----
oc process -f templates/rhdg-client-basic.yaml \
    -p APPLICATION_NAME=$APP_NAME \
    -p GIT_REPOSITORY=$GIT_REPO \
    -p APP_NAMESPACE=$APP_NAMESPACE \
    -p RHDG_CLUSTER_NAME=$RHDG_CLUSTER | oc apply -f -
----









== The rhdg8-client app


This application may be used to test many different features included in the Java implementation of Hot Rod protocol. All the tests and application logic is exposed via three REST endpoints:

* `api/basic`: Basic methods to test cache behavior: put, get, remove, restart, etc.
* `api/queries`: Methods to interact with an indexed cache to perform queries, bulk removes based on the result of queries and interact with cache indexes.
* `api/transaction`: Basic methods to test transactions.


=== Environment set up

If your client application is running on OCP, define these environment variables to simplify the following commands:
[source, bash]
----
APP_NAMESPACE="rhdg8"
APP_NAME="rhdg8-hotrod-tester"
APP_URL=$(oc get route ${APP_NAME} -n ${APP_NAMESPACE} -o template='http://{{.spec.host}}')
CACHE_NAME="distributed-01"
----

On the contrary, if your application is running locally, define these environment variables to simplify the following commands:
[source, bash]
----
APP_URL="http://localhost:8080"
CACHE_NAME="distributed-02"
----


=== Basic features

Basic operations:

[source, bash]
----
# Put bytes from 0 to 49
curl -k -G -X PUT "${APP_URL}/api/basic/cache/${CACHE_NAME}/bytes" -d size=1024 -d entries=50

# Put strings from 100 to 149
curl -k -G -X PUT "${APP_URL}/api/basic/cache/${CACHE_NAME}/string" -d minkey=100 -d entries=50

# Get Bulk from 100 to 149
curl -k -G -X GET "${APP_URL}/api/basic/cache/${CACHE_NAME}/bulk" -d minkey=100 -d entries=50

# Get byte entry 0
curl -k -G -X GET "${APP_URL}/api/basic/cache/${CACHE_NAME}/byte" -d key=0 -d show=true

# Get string entry 101
curl -k -G -X GET "${APP_URL}/api/basic/cache/${CACHE_NAME}/string" -d key=101 -d show=true

# Get keys
curl -k -G -X GET "${APP_URL}/api/basic/cache/${CACHE_NAME}/keys"

# Remove entries (From 10 to 110)
curl -k -G -X DELETE "${APP_URL}/api/basic/cache/${CACHE_NAME}" -d minkey=10 -d entries=100
----


=== Queries and indexes

TIP: These features are not tested against the cache `$CACHE_NAME`, but against a cache named `indexed-cache`. It is possible to modify the cache you are going to use in the `application.properties` file and restart the client application.





=== Transactions

ERROR: Work in progress









:sectnums!:


== Annex A: Mastering the REST API

The REST API provides a very adequate alternative to the Java Hotrod client to interact with RH Data Grid. In the following section we explore the following topics:

* Managing and configuring caches using the REST API.
* CRUD operations in a `text/plain` cache.
* CRUD operations in a `application/json` cache.
* CRUD operations in a `application/x-protostream` cache.

>> link:docs/rest/README.adoc[Click Here] <<





== Annex B: Managing SSL configuration


* The RHDG operator provides certificates by default in a secret with name `${RHDG_CLUSTER_NAME}-cert-secret`.
* Both the Spring Starter and the `infinispan-client-hotrod` accept a certificate in `.pem` format and build an in-memory KeyStore with all the certificates found under the path provided.

Add the following lines to your `application.properties` to configure the *Infinispan Spring Starter*:
[source, bash]
----
infinispan.remote.use-ssl=true
infinispan.remote.trust-store-path=config/tls.crt
infinispan.remote.sni-host-name=${RHDG_CLUSTER_NAME}.${CLUSTER_NAMESPACE}.svc
----

Add the following lines to your `application.properties` to configure the `infinispan-client-hotrod`:
[source, bash]
----
infinispan.client.hotrod.use_ssl=true
infinispan.client.hotrod.trust_store_path=config/tls.crt
infinispan.client.hotrod.sni_host_name=${RHDG_CLUSTER_NAME}.${CLUSTER_NAMESPACE}.svc
----

For more information about configuration parameters check the following resources:

* https://access.redhat.com/webassets/avalon/d/red-hat-data-grid/8.4/api/org/infinispan/client/hotrod/configuration/package-summary.html[RHDG 8.4 JavaDoc].
* https://github.com/infinispan/infinispan-spring-boot/blob/main/infinispan-spring-boot-starter-remote/src/test/resources/test-application.properties[Testing configuration of the Spring Starter].


There are other mechanisms to add the credentials to the client application for cases where you need a custom certificate or non-standard config. For such cases, you can check https://github.com/alvarolop/rhdg8-client/tree/ae88646060d81987034f7215137c04578f31e923#annex-a-managing-ssl-configuration[this old commit] previous to deleting that documentation for the sake of simplicity.






== Annex C: Comparing cache definitions

Up until now, Red Hat Data Grid does not provide a mechanism to update cache definitions easily. Most of the configuration that you might apply to a cache needs a cache restart. Therefore, the REST API does not allow cache configuration updates. You must delete it and create a new cache.

In addition to it, cache definitions retrieved with the REST API might not be identical to the definition used to create it. Data Grid adds, converts, and removes some of the parameters according to the default values.

The following commands show a mechanism to create a new cache, retrieve the modified configuration and check if it is similar or not.


If your DG is running on OCP, define these environment variables to simplify the following commands:
[source, bash]
----
CLUSTER_NAMESPACE="rhdg8"
CLUSTER_NAME="rhdg"
RHDG_URL=$(oc get route ${CLUSTER_NAME}-external -n ${CLUSTER_NAMESPACE} -o template='https://{{.spec.host}}')
CACHE_NAME="test-01"
----

On the contrary, if your DG is running locally, define these environment variables to simplify the following commands:
[source, bash]
----
RHDG_URL="https://localhost:11222"
CACHE_NAME="test-01"
----

Second, create your cache:
[source, bash]
----
curl -X POST -k --digest -u admin:password -H "Content-Type: application/json" ${RHDG_URL}/rest/v2/caches/${CACHE_NAME} --data-binary "@caches/test/$CACHE_NAME.json"
----

Third retrieve the configuration:
[source, bash]
----
curl -X GET -k --digest -u admin:password -H "Content-Type: application/json" ${RHDG_URL}/rest/v2/caches/$CACHE_NAME?action=config | jq > caches/test/$CACHE_NAME-output.json
----

Compare them using `jq`:
[source, bash]
----
jq --argfile a caches/test/$CACHE_NAME.json --argfile b caches/test/$CACHE_NAME-output.json -n '($a | (.. | arrays) |= sort) as $a | ($b | (.. | arrays) |= sort) as $b | $a == $b'
----

Delete the cache definition:
[source, bash]
----
curl -X DELETE -k --digest -u admin:password -H "Content-Type: application/json" ${RHDG_URL}/rest/v2/caches/$CACHE_NAME
----









== Annex D: Managing indexed caches

Indexed caches keep an index of the desired objects. Some operations update this index asynchronously. Therefore, there may be inconsistencies between the index and the real values stored in the cache. Use the following commands to clear and re-index your cache:

[source, bash]
----
curl -X POST -k --digest -u admin:password  ${RHDG_URL}/rest/v2/caches/distributed-01/search/indexes?action=clear
curl -X POST -k --digest -u admin:password  ${RHDG_URL}/rest/v2/caches/distributed-01/search/indexes?action=mass-index&mode=sync
----
